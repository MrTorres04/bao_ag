# -*- coding: utf-8 -*-
"""ACO para reforestación.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a1H-nRKbDk1zJL1x7CV2JKedp_2mBVP4

# **REFORESTATION PLANNING**
"""

!pip install matplotlib
!pip install seaborn
!pip install numpy


import random
import math
import numpy as np
import matplotlib.pyplot as plt
from concurrent.futures import CancelledError
import numpy as np
from copy import deepcopy
from typing import List, Dict
import pandas as pd

class ACOReforestationPlanning:
 def __init__(self, max_capacity: float, items: List[Dict], n_ants: int , alpha: float, beta: float, rho: float):
        self.items = items
        self.values = np.array([item['value'] for item in items])
        self.weights = np.array([item['weight'] for item in items])
        self.max_capacity = max_capacity

        self.n_ants = n_ants
        self.alpha = alpha
        self.beta = beta
        self.rho = rho

        self.pheromone = None
        self.best_solution = None
        self.best_fitness = None

        self.pheromone_history = []
        self.trails_history = []
        self.best_fitness_history = []

        self.tree_limits = self._count_tree_limits(items)

 def _count_tree_limits(self, items):
        limits = {}
        for item in items:
            name = item['name']
            if name not in limits:
                limits[name] = 0
            limits[name] += 1
        return limits

 def optimize(self, max_evaluations: int = 1000):
    self._initialize()
    n_evaluations = 0
    iter_fitness = 1e-10

    while n_evaluations < max_evaluations:
      trails = []
      for _ in range(self.n_ants):
        solution = self._construct_solution()
        fitness = self._evaluate(solution)
        n_evaluations += 1
        trails.append((solution, fitness))

        if self.best_fitness is None or fitness > self.best_fitness:
          self.best_solution = deepcopy(solution)
          self.best_fitness = fitness

      self._update_pheromone(trails, iter_fitness)
      iter_fitness = self.best_fitness
      self.trails_history.append(deepcopy(trails))
      self.best_fitness_history.append(deepcopy(self.best_fitness))

    return self.best_solution



 def _initialize(self):
        self.pheromone = np.ones(len(self.weights))
        self.best_solution = None
        self.best_fitness = None

        self.pheromone_history.clear()
        self.trails_history.clear()
        self.best_fitness_history.clear()


 def _evaluate(self, solution:List[int]) -> float:
      mask = np.argwhere(solution == 1).flatten()

      total_weight = 0
      total_value = 0

      tree_counter = {}
      occupied = set()
      penalty = 0
      used = {tree['name']: 0 for tree in trees}

      for i in mask:
        item = self.items[i]
        name = item['name']
        radius = next(tree['radius'] for tree in trees if tree['name'] == name)
        row, col = item['row'], item['col']

        #Verificar que el radio no se sale del tablero
        board_size = 30  # El mapa es 30x30
        if (row - radius < 0 or row + radius >= board_size or
            col - radius < 0 or col + radius >= board_size):
         return 0

         # Controlar duplicados por área ocupada
         for dx in range(-radius, radius + 1):
                for dy in range(-radius, radius + 1):
                    pos = (row + dx, col + dy)
                    if 0 <= pos[0] < 30 and 0 <= pos[1] < 30:
                        if pos in occupied:
                           penalty += 0.2
                        occupied.add(pos)
                    else:
                        return 0

        tree_counter[name] = tree_counter.get(name, 0) + 1
        total_weight += item['weight']
        total_value += item['value']

        # Verificar límites por tipo de árbol
      for name, count in tree_counter.items():
          max_allowed = next(tree['count'] for tree in trees if tree['name'] == name)
          if count > max_allowed:
              return 0

      if total_weight > self.max_capacity or total_weight == 0:
          return 0

      fitness = (total_value / total_weight)-penalty
      return fitness


 def _construct_solution(self) -> List[int]:
    solution = np.zeros(len(self.items))

    while True:
      candidates = self._get_candidates(solution)

      if len(candidates) == 0:
        break
      elif len(candidates) == 1:
        solution[candidates[0]] = 1
        break

      pheromone = self.pheromone[candidates] ** self.alpha
      heuristic = (self.values[candidates] / self.weights[candidates]) ** self.beta

      total = np.sum(pheromone * heuristic)
      probabilities = (pheromone * heuristic) / total

      solution[np.random.choice(candidates, p=probabilities)] = 1

    return solution

 def _heuristic(self, candidates: List[int]) -> np.ndarray:
      return self.values[candidates] / self.weights[candidates]

 def _get_candidates(self, solution: List[int]) -> List[int]:
      selected = np.argwhere(solution == 1).flatten()
      total_weight = sum(self.weights[selected])

      candidates = [i for i in range(len(self.items)) if i not in selected and total_weight + self.weights[i] <= self.max_capacity]
      return np.array(candidates)


 def _update_pheromone(self, trails: List[List[int]], best_fitness):
    self.pheromone_history.append(self.pheromone.copy())

    evaporation = 1 -self.rho
    self.pheromone *= evaporation

    for solution, fitness in trails:
      if fitness >0:
        delta_fitness = 1.0/(1.0 + (best_fitness - fitness)/best_fitness)
        mask = np.argwhere(solution == 1).flatten()
        self.pheromone[mask] += delta_fitness

"""## USO"""

def terrain_to_dataframe(terrain):
    data = []
    n = len(terrain)
    for i in range(n):
        for j in range(n):
            tile = terrain[i][j]
            data.append({
                "row": i,
                "col": j,
                "altitude": tile["altitude"],
                "tilt": tile["tilt"],
                "quality": tile["quality"]
            })
    return pd.DataFrame(data)

def build_aco_items_from_dataframe(df, trees=trees):
    items = []
    for _, row in df.iterrows():
        for tree in trees:
            # Verifica si se puede plantar este árbol en esta celda
            if (row['altitude'] <= tree['max_altitude'] and
                row['tilt'] <= tree['max_tilt'] and
                row['quality'] >= tree['min_quality']):
                items.append({
                    "row": row['row'],
                    "col": row['col'],
                    "name": tree['name'],
                    "weight": tree['consumption'],
                    "value": row['quality'] * 0.6 + (100 - row['tilt']) * 0.4  # heurística simple
                })
    return items

terrain = generate_terrain(30)

# 2. Convertir terreno a DataFrame
df = terrain_to_dataframe(terrain)

# 3. Generar ítems válidos con restricciones por tipo de árbol
items_with_location = build_aco_items_from_dataframe(df)
# Paso 1: construir ítems válidos para el algoritmo
aco_items = items_with_location

# Paso 2: crear y ejecutar el algoritmo
aco = ACOReforestationPlanning(max_capacity=200,items=aco_items,n_ants=150,alpha=1,beta=6,rho=0.3)
best_solution = aco.optimize(max_evaluations=1000)

# Paso 3: reconstruir valores/pesos (necesario si los cambiaste)
aco.values = np.array([item['value'] for item in aco_items])
aco.weights = np.array([item['weight'] for item in aco_items])

# Obtener los índices seleccionados
mask = np.argwhere(best_solution == 1).flatten()

# Construir salida detallada
selected_sites = [items_with_location[i] for i in mask]

# Mostrar resumen al estilo mochila clásica
print(f"Value: {np.sum(aco.values[mask])}, Weight: {np.sum(aco.weights[mask])}, Items: {mask.tolist()}")

# Mostrar información detallada por ítem
print("\nSelected Tree Placements:")
for i in mask:
    item = items_with_location[i]
    name = item.get('name', 'unknown')  # Asegúrate de que el árbol tenga esta info
    print(f"Tree: {name}, Pos: ({item['row']}, {item['col']}), Value: {item['value']}, Weight: {item['weight']}")

"""# **RESULTADOS**"""

import matplotlib.pyplot as plt
import numpy as np

# Simular una historia de fitness decreciente con algo de ruido
best_fitness_history = np.maximum(10 - np.log1p(np.arange(100)) + np.random.normal(0, 0.2, 100), 0.1)

# Graficar evolución del fitness
plt.figure(figsize=(8, 5))
plt.plot(best_fitness_history, color='green', linewidth=2)
plt.title("Evolución del Fitness (CO₂ / tiles)")
plt.xlabel("Iteración")
plt.ylabel("Fitness")
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Simular historial de feromonas (por ejemplo, en una grilla 30x30)
pheromones = np.random.rand(30, 30)

plt.figure(figsize=(8, 6))
sns.heatmap(pheromones, cmap='Oranges', xticklabels=False, yticklabels=False)
plt.title("Mapa de Feromonas Simulado")
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style('darkgrid')


# Procesar datos
fitness = np.array([[ant[1] for ant in trails] for trails in aco.trails_history])
best_fitness = np.array(aco.best_fitness_history)

# Graficar
fig, ax = plt.subplots(figsize=(6, 5))
ax.set_title('Evolución del Fitness')
ax.set_xlabel('Iteraciones')
ax.set_ylabel('Fitness')

ax.plot(best_fitness, label='Mejor fitness', color='green')

median = np.median(fitness, axis=1)
min_f = np.min(fitness, axis=1)
max_f = np.max(fitness, axis=1)
ax.plot(median, label='Mediana', color='blue')
ax.fill_between(np.arange(len(median)), min_f, max_f, alpha=0.3, color='orange', label='Rango')

plt.legend()
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt



# Extraer población: listas de soluciones por iteración
population = np.array([
    [np.array(ant[0]) for ant in trails]
    for trails in aco.trails_history
])

# Verificar que todas las soluciones tienen la misma longitud
if not all(arr.shape == population[0][0].shape for trail in population for arr in trail):
    raise ValueError("Las soluciones no tienen una estructura uniforme.")

# Calcular diversidad como suma de desviaciones estándar por posición del 'genoma'
diversity = np.sum(np.std(population, axis=1), axis=1)

# Graficar
fig, ax = plt.subplots(figsize=(6, 5))
ax.set_title('Evolución de la Diversidad')
ax.set_xlabel('Iteraciones')
ax.set_ylabel('Diversidad')
ax.plot(diversity, color='orange')
plt.tight_layout()
plt.show()

from itertools import accumulate

population = np.array([[np.array(ant[0]) for ant in trails] for trails in aco.trails_history ])

def stringify_individual(individual: List[int]) -> str:
    return ''.join([str(int(i)) for i in individual])

a = np.apply_along_axis(stringify_individual, 2, population)
a = list(accumulate(a, lambda x, y: x.union(set(y)), initial=set()))

fig, axs = plt.subplots(figsize=(5,5))
axs.plot([len(x) for x in a], color='orange')
axs.set_title('Unique solutions evolution')
axs.set_xlabel('Iterations')
axs.set_ylabel('Unique solutions')
