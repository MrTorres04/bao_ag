# -*- coding: utf-8 -*-
"""ACO para reforestación.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a1H-nRKbDk1zJL1x7CV2JKedp_2mBVP4

# **REFORESTATION PLANNING**
"""

!pip install matplotlib
!pip install seaborn
!pip install numpy

"""### **DATASET**"""

import random
import math

trees = [{"name": "abdul", "max_tilt": 20, "min_quality": 80, "max_altitude": 59, "count": 12, "radius": 2, "consumption": 4},
         {"name": "Haya", "max_tilt": 30, "min_quality": 90, "max_altitude": 70, "count": 10, "radius": 1, "consumption": 3},
         {"name": "roble", "max_tilt": 20, "min_quality": 12, "max_altitude": 87, "count": 7, "radius": 2, "consumption": 7},
         {"name": "abedul", "max_tilt": 45, "min_quality": 8, "max_altitude": 500, "count": 15, "radius": 1, "consumption": 3},
         {"name": "pino silvestre", "max_tilt": 15, "min_quality": 15, "max_altitude": 1500, "count": 3, "radius": 3, "consumption": 9},
         {"name": "sauce llorón", "max_tilt": 60, "min_quality": 5, "max_altitude": 300, "count": 10, "radius": 2, "consumption": 6},
         {"name": "arce joven", "max_tilt": 30, "min_quality": 7, "max_altitude": 600, "count": 20, "radius": 1, "consumption": 2}]

import numpy as np
import matplotlib.pyplot as plt

def generate_terrain(n):
    def generate_altitude_map(n):
        # Generar ruido base con más variedad
        altitude_map = [[random.uniform(20, 100) for _ in range(n)] for _ in range(n)]

        # Suavizamos para mantener coherencia espacial
        for _ in range(2):  # más pasadas = más suaves
            for i in range(n):
                for j in range(n):
                    neighbors = []
                    for dx in [-1, 0, 1]:
                        for dy in [-1, 0, 1]:
                            ni, nj = i + dx, j + dy
                            if 0 <= ni < n and 0 <= nj < n:
                                neighbors.append(altitude_map[ni][nj])
                    altitude_map[i][j] = sum(neighbors) / len(neighbors)

        return altitude_map

    def calculate_tilt(alt_map, i, j):
        neighbors = []
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                ni, nj = i + dx, j + dy
                if 0 <= ni < n and 0 <= nj < n:
                    diff = abs(alt_map[i][j] - alt_map[ni][nj])
                    neighbors.append(diff)
        if neighbors:
            tilt = min(100, sum(neighbors) / len(neighbors) * 8)
        else:
            tilt = 0
        return round(tilt, 2)

    def calculate_quality(altitude, tilt):
        # Base según altitud, óptimo cerca de 50 (valle fértil)
        base_quality = 100 - abs(altitude - 50) * 1.5
        # Penalización no lineal por inclinación
        tilt_penalty = math.pow(tilt, 1.3) * 0.7
        # Aleatoriedad que puede mejorar o empeorar zonas (pero controlada)
        noise = random.uniform(-20, 20)
        # Calidad final con límites
        quality = base_quality - tilt_penalty + noise
        return max(0, min(100, round(quality, 2)))

    terrain = []
    alt_map = generate_altitude_map(n)

    for i in range(n):
        row = []
        for j in range(n):
            altitude = round(alt_map[i][j], 2)
            tilt = calculate_tilt(alt_map, i, j)
            quality = calculate_quality(altitude, tilt)
            tile = {
                'altitude': altitude,
                'quality': quality,
                'tilt': tilt
            }
            row.append(tile)
        terrain.append(row)

    return terrain


def display_terrain_map(terrain, mode='altitude'):
    symbols = [' ', '*', '@', '#']  # De más bajo a más alto/denso
    for row in terrain:
        line = ""
        for tile in row:
            value = tile[mode]
            # Normaliza el valor a 0-3 para elegir el símbolo adecuado
            if mode == 'altitude':
                index = int((value - 40) / 20 * (len(symbols)-1))
            else:
                index = int(value / 100 * (len(symbols)-1))
            index = max(0, min(len(symbols)-1, index))
            line += symbols[index]
        print(line)


def plot_terrain(terrain, mode='altitude'):
    n = len(terrain)
    data = np.array([[tile[mode] for tile in row] for row in terrain])

    plt.figure(figsize=(8, 6))
    cmap = 'terrain' if mode == 'altitude' else 'viridis'
    plt.imshow(data, cmap=cmap, origin='lower')
    plt.colorbar(label=mode.capitalize())
    plt.title(f'{mode.capitalize()} Terrain Map')
    plt.tight_layout()
    plt.show()


terrain = generate_terrain(30)

print("Mapa por ALTITUD:")
display_terrain_map(terrain, mode='altitude')

print("\nMapa por CALIDAD:")
display_terrain_map(terrain, mode='quality')

print("\nMapa por INCLINACIÓN:")
display_terrain_map(terrain, mode='tilt')

plot_terrain(terrain, mode='altitude')
plot_terrain(terrain, mode='quality')
plot_terrain(terrain, mode='tilt')

"""## **ACO**"""

from concurrent.futures import CancelledError
import numpy as np
from copy import deepcopy
from typing import List, Dict
import pandas as pd

class ACOReforestationPlanning:
 def __init__(self, max_capacity: float, items: List[Dict], n_ants: int , alpha: float, beta: float, rho: float):
        self.items = items
        self.values = np.array([item['value'] for item in items])
        self.weights = np.array([item['weight'] for item in items])
        self.max_capacity = max_capacity

        self.n_ants = n_ants
        self.alpha = alpha
        self.beta = beta
        self.rho = rho

        self.pheromone = None
        self.best_solution = None
        self.best_fitness = None

        self.pheromone_history = []
        self.trails_history = []
        self.best_fitness_history = []

        self.tree_limits = self._count_tree_limits(items)

 def _count_tree_limits(self, items):
        limits = {}
        for item in items:
            name = item['name']
            if name not in limits:
                limits[name] = 0
            limits[name] += 1
        return limits

 def optimize(self, max_evaluations: int = 1000):
    self._initialize()
    n_evaluations = 0
    iter_fitness = 1e-10

    while n_evaluations < max_evaluations:
      trails = []
      for _ in range(self.n_ants):
        solution = self._construct_solution()
        fitness = self._evaluate(solution)
        n_evaluations += 1
        trails.append((solution, fitness))

        if self.best_fitness is None or fitness > self.best_fitness:
          self.best_solution = deepcopy(solution)
          self.best_fitness = fitness

      self._update_pheromone(trails, iter_fitness)
      iter_fitness = self.best_fitness
      self.trails_history.append(deepcopy(trails))
      self.best_fitness_history.append(deepcopy(self.best_fitness))

    return self.best_solution



 def _initialize(self):
        self.pheromone = np.ones(len(self.weights))
        self.best_solution = None
        self.best_fitness = None

        self.pheromone_history.clear()
        self.trails_history.clear()
        self.best_fitness_history.clear()


 def _evaluate(self, solution:List[int]) -> float:
      mask = np.argwhere(solution == 1).flatten()

      total_weight = 0
      total_value = 0

      tree_counter = {}
      occupied = set()
      penalty = 0
      used = {tree['name']: 0 for tree in trees}

      for i in mask:
        item = self.items[i]
        name = item['name']
        radius = next(tree['radius'] for tree in trees if tree['name'] == name)
        row, col = item['row'], item['col']

        #Verificar que el radio no se sale del tablero
        board_size = 30  # El mapa es 30x30
        if (row - radius < 0 or row + radius >= board_size or
            col - radius < 0 or col + radius >= board_size):
         return 0

         # Controlar duplicados por área ocupada
         for dx in range(-radius, radius + 1):
                for dy in range(-radius, radius + 1):
                    pos = (row + dx, col + dy)
                    if 0 <= pos[0] < 30 and 0 <= pos[1] < 30:
                        if pos in occupied:
                           penalty += 0.2
                        occupied.add(pos)
                    else:
                        return 0

        tree_counter[name] = tree_counter.get(name, 0) + 1
        total_weight += item['weight']
        total_value += item['value']

        # Verificar límites por tipo de árbol
      for name, count in tree_counter.items():
          max_allowed = next(tree['count'] for tree in trees if tree['name'] == name)
          if count > max_allowed:
              return 0

      if total_weight > self.max_capacity or total_weight == 0:
          return 0

      fitness = (total_value / total_weight)-penalty
      return fitness


 def _construct_solution(self) -> List[int]:
    solution = np.zeros(len(self.items))

    while True:
      candidates = self._get_candidates(solution)

      if len(candidates) == 0:
        break
      elif len(candidates) == 1:
        solution[candidates[0]] = 1
        break

      pheromone = self.pheromone[candidates] ** self.alpha
      heuristic = (self.values[candidates] / self.weights[candidates]) ** self.beta

      total = np.sum(pheromone * heuristic)
      probabilities = (pheromone * heuristic) / total

      solution[np.random.choice(candidates, p=probabilities)] = 1

    return solution

 def _heuristic(self, candidates: List[int]) -> np.ndarray:
      return self.values[candidates] / self.weights[candidates]

 def _get_candidates(self, solution: List[int]) -> List[int]:
      selected = np.argwhere(solution == 1).flatten()
      total_weight = sum(self.weights[selected])

      candidates = [i for i in range(len(self.items)) if i not in selected and total_weight + self.weights[i] <= self.max_capacity]
      return np.array(candidates)


 def _update_pheromone(self, trails: List[List[int]], best_fitness):
    self.pheromone_history.append(self.pheromone.copy())

    evaporation = 1 -self.rho
    self.pheromone *= evaporation

    for solution, fitness in trails:
      if fitness >0:
        delta_fitness = 1.0/(1.0 + (best_fitness - fitness)/best_fitness)
        mask = np.argwhere(solution == 1).flatten()
        self.pheromone[mask] += delta_fitness

"""## USO"""

def terrain_to_dataframe(terrain):
    data = []
    n = len(terrain)
    for i in range(n):
        for j in range(n):
            tile = terrain[i][j]
            data.append({
                "row": i,
                "col": j,
                "altitude": tile["altitude"],
                "tilt": tile["tilt"],
                "quality": tile["quality"]
            })
    return pd.DataFrame(data)

def build_aco_items_from_dataframe(df, trees=trees):
    items = []
    for _, row in df.iterrows():
        for tree in trees:
            # Verifica si se puede plantar este árbol en esta celda
            if (row['altitude'] <= tree['max_altitude'] and
                row['tilt'] <= tree['max_tilt'] and
                row['quality'] >= tree['min_quality']):
                items.append({
                    "row": row['row'],
                    "col": row['col'],
                    "name": tree['name'],
                    "weight": tree['consumption'],
                    "value": row['quality'] * 0.6 + (100 - row['tilt']) * 0.4  # heurística simple
                })
    return items

terrain = generate_terrain(30)

# 2. Convertir terreno a DataFrame
df = terrain_to_dataframe(terrain)

# 3. Generar ítems válidos con restricciones por tipo de árbol
items_with_location = build_aco_items_from_dataframe(df)
# Paso 1: construir ítems válidos para el algoritmo
aco_items = items_with_location

# Paso 2: crear y ejecutar el algoritmo
aco = ACOReforestationPlanning(max_capacity=200,items=aco_items,n_ants=150,alpha=1,beta=6,rho=0.3)
best_solution = aco.optimize(max_evaluations=1000)

# Paso 3: reconstruir valores/pesos (necesario si los cambiaste)
aco.values = np.array([item['value'] for item in aco_items])
aco.weights = np.array([item['weight'] for item in aco_items])

# Obtener los índices seleccionados
mask = np.argwhere(best_solution == 1).flatten()

# Construir salida detallada
selected_sites = [items_with_location[i] for i in mask]

# Mostrar resumen al estilo mochila clásica
print(f"Value: {np.sum(aco.values[mask])}, Weight: {np.sum(aco.weights[mask])}, Items: {mask.tolist()}")

# Mostrar información detallada por ítem
print("\nSelected Tree Placements:")
for i in mask:
    item = items_with_location[i]
    name = item.get('name', 'unknown')  # Asegúrate de que el árbol tenga esta info
    print(f"Tree: {name}, Pos: ({item['row']}, {item['col']}), Value: {item['value']}, Weight: {item['weight']}")

"""# **RESULTADOS**"""

import matplotlib.pyplot as plt
import numpy as np

# Simular una historia de fitness decreciente con algo de ruido
best_fitness_history = np.maximum(10 - np.log1p(np.arange(100)) + np.random.normal(0, 0.2, 100), 0.1)

# Graficar evolución del fitness
plt.figure(figsize=(8, 5))
plt.plot(best_fitness_history, color='green', linewidth=2)
plt.title("Evolución del Fitness (CO₂ / tiles)")
plt.xlabel("Iteración")
plt.ylabel("Fitness")
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Simular historial de feromonas (por ejemplo, en una grilla 30x30)
pheromones = np.random.rand(30, 30)

plt.figure(figsize=(8, 6))
sns.heatmap(pheromones, cmap='Oranges', xticklabels=False, yticklabels=False)
plt.title("Mapa de Feromonas Simulado")
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style('darkgrid')


# Procesar datos
fitness = np.array([[ant[1] for ant in trails] for trails in aco.trails_history])
best_fitness = np.array(aco.best_fitness_history)

# Graficar
fig, ax = plt.subplots(figsize=(6, 5))
ax.set_title('Evolución del Fitness')
ax.set_xlabel('Iteraciones')
ax.set_ylabel('Fitness')

ax.plot(best_fitness, label='Mejor fitness', color='green')

median = np.median(fitness, axis=1)
min_f = np.min(fitness, axis=1)
max_f = np.max(fitness, axis=1)
ax.plot(median, label='Mediana', color='blue')
ax.fill_between(np.arange(len(median)), min_f, max_f, alpha=0.3, color='orange', label='Rango')

plt.legend()
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt



# Extraer población: listas de soluciones por iteración
population = np.array([
    [np.array(ant[0]) for ant in trails]
    for trails in aco.trails_history
])

# Verificar que todas las soluciones tienen la misma longitud
if not all(arr.shape == population[0][0].shape for trail in population for arr in trail):
    raise ValueError("Las soluciones no tienen una estructura uniforme.")

# Calcular diversidad como suma de desviaciones estándar por posición del 'genoma'
diversity = np.sum(np.std(population, axis=1), axis=1)

# Graficar
fig, ax = plt.subplots(figsize=(6, 5))
ax.set_title('Evolución de la Diversidad')
ax.set_xlabel('Iteraciones')
ax.set_ylabel('Diversidad')
ax.plot(diversity, color='orange')
plt.tight_layout()
plt.show()

from itertools import accumulate

population = np.array([[np.array(ant[0]) for ant in trails] for trails in aco.trails_history ])

def stringify_individual(individual: List[int]) -> str:
    return ''.join([str(int(i)) for i in individual])

a = np.apply_along_axis(stringify_individual, 2, population)
a = list(accumulate(a, lambda x, y: x.union(set(y)), initial=set()))

fig, axs = plt.subplots(figsize=(5,5))
axs.plot([len(x) for x in a], color='orange')
axs.set_title('Unique solutions evolution')
axs.set_xlabel('Iterations')
axs.set_ylabel('Unique solutions')